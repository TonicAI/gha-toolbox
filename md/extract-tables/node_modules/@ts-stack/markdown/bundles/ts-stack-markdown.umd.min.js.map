{"version":3,"sources":["../../projects/markdown/src/interfaces.ts","../../projects/markdown/src/extend-regexp.ts","../../projects/markdown/src/helpers.ts","../../node_modules/tslib/tslib.es6.js","../../projects/markdown/src/renderer.ts","../../projects/markdown/src/inline-lexer.ts","../../projects/markdown/src/parser.ts","../../projects/markdown/src/marked.ts","../../projects/markdown/src/block-lexer.ts"],"names":["TokenType","ExtendRegexp","regex","flags","this","source","prototype","setGroup","groupName","groupRegexp","newRegexp","replace","getRegexp","RegExp","escapeTest","escapeReplace","replacements","&","<",">","\"","'","escapeTestNoEncode","escapeReplaceNoEncode","escape","html","encode","test","ch","unescape","_","n","toLowerCase","charAt","String","fromCharCode","parseInt","substring","gfm","tables","breaks","pedantic","sanitize","mangle","smartLists","silent","langPrefix","smartypants","headerPrefix","xhtml","Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","Renderer","options","Marked","code","lang","escaped","highlight","out","blockquote","quote","heading","text","level","raw","hr","list","body","ordered","type","listitem","paragraph","table","header","tablerow","content","tablecell","align","strong","em","codespan","br","del","link","href","title","prot","decodeURIComponent","e","indexOf","image","InlineLexer","staticThis","links","renderer","Error","setRules","output","src","getRulesBase","rulesBase","base","autolink","tag","reflink","nolink","_inside","_href","getRulesPedantic","rulesPedantic","assign","getRulesGfm","rulesGfm","url","getRulesBreaks","rulesBreaks","inline","rules","hasRulesGfm","undefined","nextPart","execArr","exec","inLink","sanitizer","outputLink","keyLink","trim","charCodeAt","str","Math","random","toString","Parser","simpleRenderers","line","tokens","token","parse","inlineLexer","reverse","tok","debug","outToken","split","pop","getNextElement","parseText","nextElement","space","isNoP","depth","listStart","listEnd","listItemStart","listItemEnd","looseItemStart","cell","_b","cells","_c","row","j","blockquoteStart","blockquoteEnd","pre","errMsg","console","log","setOptions","setBlockRule","regexp","BlockLexer","simpleRules","push","_a","callBlockLexer","callParser","callMe","origin","slice","parser","result","map","lex","err","message","MarkedOptions","top","isBlockQuote","getTokens","newline","lheading","def","bullet","item","fences","group1","group2","getRulesTable","rulesTables","nptable","hasRulesTables","mainLoop","td","bull","match","blockBullet","loose","join","attr","isPre"],"mappings":"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","sourcesContent":["/**\n * @license\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { escape, unescape } from './helpers';\nimport { Renderer } from './renderer';\n\nexport interface Obj {\n  [key: string]: any;\n}\n\nexport interface RulesBlockBase {\n  newline: RegExp;\n  code: RegExp;\n  hr: RegExp;\n  heading: RegExp;\n  lheading: RegExp;\n  blockquote: RegExp;\n  list: RegExp;\n  html: RegExp;\n  def: RegExp;\n  paragraph: RegExp;\n  text: RegExp;\n  bullet: RegExp;\n  /**\n   * List item (<li>).\n   */\n  item: RegExp;\n}\n\nexport interface RulesBlockGfm extends RulesBlockBase {\n  fences: RegExp;\n}\n\nexport interface RulesBlockTables extends RulesBlockGfm {\n  nptable: RegExp;\n  table: RegExp;\n}\n\nexport interface Link {\n  href: string;\n  title: string;\n}\n\nexport interface Links {\n  [key: string]: Link;\n}\n\nexport enum TokenType {\n  space = 1,\n  text,\n  paragraph,\n  heading,\n  listStart,\n  listEnd,\n  looseItemStart,\n  looseItemEnd,\n  listItemStart,\n  listItemEnd,\n  blockquoteStart,\n  blockquoteEnd,\n  code,\n  table,\n  html,\n  hr\n}\n\nexport type Align = 'center' | 'left' | 'right';\n\nexport interface Token {\n  type: number | string;\n  text?: string;\n  lang?: string;\n  depth?: number;\n  header?: string[];\n  align?: Align[];\n  cells?: string[][];\n  ordered?: boolean;\n  pre?: boolean;\n  escaped?: boolean;\n  execArr?: RegExpExecArray;\n  /**\n   * Used for debugging. Identifies the line number in the resulting HTML file.\n   */\n  line?: number;\n}\n\nexport interface RulesInlineBase {\n  escape: RegExp;\n  autolink: RegExp;\n  tag: RegExp;\n  link: RegExp;\n  reflink: RegExp;\n  nolink: RegExp;\n  strong: RegExp;\n  em: RegExp;\n  code: RegExp;\n  br: RegExp;\n  text: RegExp;\n  _inside: RegExp;\n  _href: RegExp;\n}\n\nexport interface RulesInlinePedantic extends RulesInlineBase {}\n\n/**\n * GFM Inline Grammar\n */\nexport interface RulesInlineGfm extends RulesInlineBase {\n  url: RegExp;\n  del: RegExp;\n}\n\nexport interface RulesInlineBreaks extends RulesInlineGfm {}\n\nexport class MarkedOptions {\n  gfm?: boolean = true;\n  tables?: boolean = true;\n  breaks?: boolean = false;\n  pedantic?: boolean = false;\n  sanitize?: boolean = false;\n  sanitizer?: (text: string) => string;\n  mangle?: boolean = true;\n  smartLists?: boolean = false;\n  silent?: boolean = false;\n  /**\n   * @param code The section of code to pass to the highlighter.\n   * @param lang The programming language specified in the code block.\n   */\n  highlight?: (code: string, lang?: string) => string;\n  langPrefix?: string = 'lang-';\n  smartypants?: boolean = false;\n  headerPrefix?: string = '';\n  /**\n   * An object containing functions to render tokens to HTML. Default: `new Renderer()`\n   */\n  renderer?: Renderer;\n  /**\n   * Self-close the tags for void elements (&lt;br/&gt;, &lt;img/&gt;, etc.)\n   * with a \"/\" as required by XHTML.\n   */\n  xhtml?: boolean = false;\n  /**\n   * The function that will be using to escape HTML entities.\n   * By default using inner helper.\n   */\n  escape?: (html: string, encode?: boolean) => string = escape;\n  /**\n   * The function that will be using to unescape HTML entities.\n   * By default using inner helper.\n   */\n  unescape?: (html: string) => string = unescape;\n  /**\n   * If set to `true`, an inline text will not be taken in paragraph.\n   *\n   * ```ts\n   * // isNoP == false\n   * Marked.parse('some text'); // returns '<p>some text</p>'\n   *\n   * Marked.setOptions({isNoP: true});\n   *\n   * Marked.parse('some text'); // returns 'some text'\n   * ```\n   */\n  isNoP?: boolean;\n}\n\nexport interface LexerReturns {\n  tokens: Token[];\n  links: Links;\n}\n\nexport interface DebugReturns extends LexerReturns {\n  result: string;\n}\n\nexport interface Replacements {\n  [key: string]: string;\n}\n\nexport interface RulesInlineCallback {\n  regexp?: RegExp;\n  condition(): RegExp;\n  tokenize(execArr: RegExpExecArray): void;\n}\n\nexport type SimpleRenderer = (execArr?: RegExpExecArray) => string;\n","/*\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nexport class ExtendRegexp {\n  private source: string;\n  private flags: string;\n\n  constructor(regex: RegExp, flags: string = '') {\n    this.source = regex.source;\n    this.flags = flags;\n  }\n\n  /**\n   * Extend regular expression.\n   *\n   * @param groupName Regular expression for search a group name.\n   * @param groupRegexp Regular expression of named group.\n   */\n  setGroup(groupName: RegExp | string, groupRegexp: RegExp | string): this {\n    let newRegexp: string = typeof groupRegexp == 'string' ? groupRegexp : groupRegexp.source;\n    newRegexp = newRegexp.replace(/(^|[^\\[])\\^/g, '$1');\n\n    // Extend regexp.\n    this.source = this.source.replace(groupName, newRegexp);\n    return this;\n  }\n\n  /**\n   * Returns a result of extending a regular expression.\n   */\n  getRegexp(): RegExp {\n    return new RegExp(this.source, this.flags);\n  }\n}\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { Replacements } from './interfaces';\n\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst replacements: Replacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  // tslint:disable-next-line:quotemark\n  \"'\": '&#39;',\n};\n\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, (ch: string) => replacements[ch]);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, (ch: string) => replacements[ch]);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // Explicitly match decimal, hex, and named HTML entities\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/gi, function (_, n) {\n    n = n.toLowerCase();\n\n    if (n === 'colon') {\n      return ':';\n    }\n\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n\n    return '';\n  });\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { Align, MarkedOptions } from './interfaces';\nimport { Marked } from './marked';\n\nexport class Renderer {\n  protected options: MarkedOptions;\n\n  constructor(options?: MarkedOptions) {\n    this.options = options || Marked.options;\n  }\n\n  code(code: string, lang?: string, escaped?: boolean): string {\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    if (!lang) {\n      return '\\n<pre><code>' + (escaped ? code : this.options.escape(code, true)) + '\\n</code></pre>\\n';\n    }\n\n    return (\n      '\\n<pre><code class=\"' +\n      this.options.langPrefix +\n      this.options.escape(lang, true) +\n      '\">' +\n      (escaped ? code : this.options.escape(code, true)) +\n      '\\n</code></pre>\\n'\n    );\n  }\n\n  blockquote(quote: string): string {\n    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n  }\n\n  html(html: string): string {\n    return html;\n  }\n\n  heading(text: string, level: number, raw: string): string {\n    const id: string = this.options.headerPrefix + raw.toLowerCase().replace(/[^\\w]+/g, '-');\n\n    return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n  }\n\n  hr(): string {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body: string, ordered?: boolean): string {\n    const type = ordered ? 'ol' : 'ul';\n\n    return `\\n<${type}>\\n${body}</${type}>\\n`;\n  }\n\n  listitem(text: string): string {\n    return '<li>' + text + '</li>\\n';\n  }\n\n  paragraph(text: string): string {\n    return '<p>' + text + '</p>\\n';\n  }\n\n  table(header: string, body: string): string {\n    return `\n<table>\n<thead>\n${header}</thead>\n<tbody>\n${body}</tbody>\n</table>\n`;\n  }\n\n  tablerow(content: string): string {\n    return '<tr>\\n' + content + '</tr>\\n';\n  }\n\n  tablecell(content: string, flags: { header?: boolean; align?: Align }): string {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align ? '<' + type + ' style=\"text-align:' + flags.align + '\">' : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  }\n\n  // *** Inline level renderer methods. ***\n\n  strong(text: string): string {\n    return '<strong>' + text + '</strong>';\n  }\n\n  em(text: string): string {\n    return '<em>' + text + '</em>';\n  }\n\n  codespan(text: string): string {\n    return '<code>' + text + '</code>';\n  }\n\n  br(): string {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  del(text: string): string {\n    return '<del>' + text + '</del>';\n  }\n\n  link(href: string, title: string, text: string): string {\n    if (this.options.sanitize) {\n      let prot: string;\n\n      try {\n        prot = decodeURIComponent(this.options.unescape(href))\n          .replace(/[^\\w:]/g, '')\n          .toLowerCase();\n      } catch (e) {\n        return text;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return text;\n      }\n    }\n\n    let out = '<a href=\"' + href + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += '>' + text + '</a>';\n\n    return out;\n  }\n\n  image(href: string, title: string, text: string): string {\n    let out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += this.options.xhtml ? '/>' : '>';\n\n    return out;\n  }\n\n  text(text: string): string {\n    return text;\n  }\n}\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { ExtendRegexp } from './extend-regexp';\nimport {\n  Link,\n  Links,\n  MarkedOptions,\n  RulesInlineBase,\n  RulesInlineBreaks,\n  RulesInlineCallback,\n  RulesInlineGfm,\n  RulesInlinePedantic,\n} from './interfaces';\nimport { Marked } from './marked';\nimport { Renderer } from './renderer';\n\n/**\n * Inline Lexer & Compiler.\n */\nexport class InlineLexer {\n  protected static rulesBase: RulesInlineBase = null;\n  /**\n   * Pedantic Inline Grammar.\n   */\n  protected static rulesPedantic: RulesInlinePedantic = null;\n  /**\n   * GFM Inline Grammar\n   */\n  protected static rulesGfm: RulesInlineGfm = null;\n  /**\n   * GFM + Line Breaks Inline Grammar.\n   */\n  protected static rulesBreaks: RulesInlineBreaks = null;\n  protected rules: RulesInlineBase | RulesInlinePedantic | RulesInlineGfm | RulesInlineBreaks;\n  protected renderer: Renderer;\n  protected inLink: boolean;\n  protected hasRulesGfm: boolean;\n  protected ruleCallbacks: RulesInlineCallback[];\n\n  constructor(\n    protected staticThis: typeof InlineLexer,\n    protected links: Links,\n    protected options: MarkedOptions = Marked.options,\n    renderer?: Renderer\n  ) {\n    this.renderer = renderer || this.options.renderer || new Renderer(this.options);\n\n    if (!this.links) {\n      throw new Error(`InlineLexer requires 'links' parameter.`);\n    }\n\n    this.setRules();\n  }\n\n  /**\n   * Static Lexing/Compiling Method.\n   */\n  static output(src: string, links: Links, options: MarkedOptions): string {\n    const inlineLexer = new this(this, links, options);\n    return inlineLexer.output(src);\n  }\n\n  protected static getRulesBase(): RulesInlineBase {\n    if (this.rulesBase) {\n      return this.rulesBase;\n    }\n\n    /**\n     * Inline-Level Grammar.\n     */\n    const base: RulesInlineBase = {\n      escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n      autolink: /^<([^ <>]+(@|:\\/)[^ <>]+)>/,\n      tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^<'\">])*?>/,\n      link: /^!?\\[(inside)\\]\\(href\\)/,\n      reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n      nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n      strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n      em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n      code: /^(`+)([\\s\\S]*?[^`])\\1(?!`)/,\n      br: /^ {2,}\\n(?!\\s*$)/,\n      text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/,\n      _inside: /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/,\n      _href: /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/,\n    };\n\n    base.link = new ExtendRegexp(base.link).setGroup('inside', base._inside).setGroup('href', base._href).getRegexp();\n\n    base.reflink = new ExtendRegexp(base.reflink).setGroup('inside', base._inside).getRegexp();\n\n    return (this.rulesBase = base);\n  }\n\n  protected static getRulesPedantic(): RulesInlinePedantic {\n    if (this.rulesPedantic) {\n      return this.rulesPedantic;\n    }\n\n    return (this.rulesPedantic = {\n      ...this.getRulesBase(),\n      ...{\n        strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n      },\n    });\n  }\n\n  protected static getRulesGfm(): RulesInlineGfm {\n    if (this.rulesGfm) {\n      return this.rulesGfm;\n    }\n\n    const base = this.getRulesBase();\n\n    const escape = new ExtendRegexp(base.escape).setGroup('])', '~|])').getRegexp();\n\n    const text = new ExtendRegexp(base.text).setGroup(']|', '~]|').setGroup('|', '|https?://|').getRegexp();\n\n    return (this.rulesGfm = {\n      ...base,\n      ...{\n        escape,\n        url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n        del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n        text,\n      },\n    });\n  }\n\n  protected static getRulesBreaks(): RulesInlineBreaks {\n    if (this.rulesBreaks) {\n      return this.rulesBreaks;\n    }\n\n    const inline = this.getRulesGfm();\n    const gfm = this.getRulesGfm();\n\n    return (this.rulesBreaks = {\n      ...gfm,\n      ...{\n        br: new ExtendRegexp(inline.br).setGroup('{2,}', '*').getRegexp(),\n        text: new ExtendRegexp(gfm.text).setGroup('{2,}', '*').getRegexp(),\n      },\n    });\n  }\n\n  protected setRules() {\n    if (this.options.gfm) {\n      if (this.options.breaks) {\n        this.rules = this.staticThis.getRulesBreaks();\n      } else {\n        this.rules = this.staticThis.getRulesGfm();\n      }\n    } else if (this.options.pedantic) {\n      this.rules = this.staticThis.getRulesPedantic();\n    } else {\n      this.rules = this.staticThis.getRulesBase();\n    }\n\n    this.hasRulesGfm = (this.rules as RulesInlineGfm).url !== undefined;\n  }\n\n  /**\n   * Lexing/Compiling.\n   */\n  output(nextPart: string): string {\n    nextPart = nextPart;\n    let execArr: RegExpExecArray;\n    let out = '';\n\n    while (nextPart) {\n      // escape\n      if ((execArr = this.rules.escape.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += execArr[1];\n        continue;\n      }\n\n      // autolink\n      if ((execArr = this.rules.autolink.exec(nextPart))) {\n        let text: string;\n        let href: string;\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[2] === '@') {\n          text = this.options.escape(\n            execArr[1].charAt(6) === ':' ? this.mangle(execArr[1].substring(7)) : this.mangle(execArr[1])\n          );\n          href = this.mangle('mailto:') + text;\n        } else {\n          text = this.options.escape(execArr[1]);\n          href = text;\n        }\n\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.inLink && this.hasRulesGfm && (execArr = (this.rules as RulesInlineGfm).url.exec(nextPart))) {\n        let text: string;\n        let href: string;\n        nextPart = nextPart.substring(execArr[0].length);\n        text = this.options.escape(execArr[1]);\n        href = text;\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // tag\n      if ((execArr = this.rules.tag.exec(nextPart))) {\n        if (!this.inLink && /^<a /i.test(execArr[0])) {\n          this.inLink = true;\n        } else if (this.inLink && /^<\\/a>/i.test(execArr[0])) {\n          this.inLink = false;\n        }\n\n        nextPart = nextPart.substring(execArr[0].length);\n\n        out += this.options.sanitize\n          ? this.options.sanitizer\n            ? this.options.sanitizer(execArr[0])\n            : this.options.escape(execArr[0])\n          : execArr[0];\n        continue;\n      }\n\n      // link\n      if ((execArr = this.rules.link.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.inLink = true;\n\n        out += this.outputLink(execArr, {\n          href: execArr[2],\n          title: execArr[3],\n        });\n\n        this.inLink = false;\n        continue;\n      }\n\n      // reflink, nolink\n      if ((execArr = this.rules.reflink.exec(nextPart)) || (execArr = this.rules.nolink.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const keyLink = (execArr[2] || execArr[1]).replace(/\\s+/g, ' ');\n        const link = this.links[keyLink.toLowerCase()];\n\n        if (!link || !link.href) {\n          out += execArr[0].charAt(0);\n          nextPart = execArr[0].substring(1) + nextPart;\n          continue;\n        }\n\n        this.inLink = true;\n        out += this.outputLink(execArr, link);\n        this.inLink = false;\n        continue;\n      }\n\n      // strong\n      if ((execArr = this.rules.strong.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.strong(this.output(execArr[2] || execArr[1]));\n        continue;\n      }\n\n      // em\n      if ((execArr = this.rules.em.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.em(this.output(execArr[2] || execArr[1]));\n        continue;\n      }\n\n      // code\n      if ((execArr = this.rules.code.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.codespan(this.options.escape(execArr[2].trim(), true));\n        continue;\n      }\n\n      // br\n      if ((execArr = this.rules.br.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.br();\n        continue;\n      }\n\n      // del (gfm)\n      if (this.hasRulesGfm && (execArr = (this.rules as RulesInlineGfm).del.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.del(this.output(execArr[1]));\n        continue;\n      }\n\n      // text\n      if ((execArr = this.rules.text.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.text(this.options.escape(this.smartypants(execArr[0])));\n        continue;\n      }\n\n      if (nextPart) {\n        throw new Error('Infinite loop on byte: ' + nextPart.charCodeAt(0));\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Compile Link.\n   */\n  protected outputLink(execArr: RegExpExecArray, link: Link) {\n    const href = this.options.escape(link.href);\n    const title = link.title ? this.options.escape(link.title) : null;\n\n    return execArr[0].charAt(0) !== '!'\n      ? this.renderer.link(href, title, this.output(execArr[1]))\n      : this.renderer.image(href, title, this.options.escape(execArr[1]));\n  }\n\n  /**\n   * Smartypants Transformations.\n   */\n  protected smartypants(text: string) {\n    if (!this.options.smartypants) {\n      return text;\n    }\n\n    return (\n      text\n        // em-dashes\n        .replace(/---/g, '\\u2014')\n        // en-dashes\n        .replace(/--/g, '\\u2013')\n        // opening singles\n        .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n        // closing singles & apostrophes\n        .replace(/'/g, '\\u2019')\n        // opening doubles\n        .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n        // closing doubles\n        .replace(/\"/g, '\\u201d')\n        // ellipses\n        .replace(/\\.{3}/g, '\\u2026')\n    );\n  }\n\n  /**\n   * Mangle Links.\n   */\n  protected mangle(text: string) {\n    if (!this.options.mangle) {\n      return text;\n    }\n\n    let out = '';\n    const length = text.length;\n\n    for (let i = 0; i < length; i++) {\n      let str: string;\n\n      if (Math.random() > 0.5) {\n        str = 'x' + text.charCodeAt(i).toString(16);\n      }\n\n      out += '&#' + str + ';';\n    }\n\n    return out;\n  }\n}\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { InlineLexer } from './inline-lexer';\nimport { Links, MarkedOptions, SimpleRenderer, Token, TokenType } from './interfaces';\nimport { Marked } from './marked';\nimport { Renderer } from './renderer';\n\n/**\n * Parsing & Compiling.\n */\nexport class Parser {\n  simpleRenderers: SimpleRenderer[] = [];\n  protected tokens: Token[];\n  protected token: Token;\n  protected inlineLexer: InlineLexer;\n  protected options: MarkedOptions;\n  protected renderer: Renderer;\n  protected line: number = 0;\n\n  constructor(options?: MarkedOptions) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || Marked.options;\n    this.renderer = this.options.renderer || new Renderer(this.options);\n  }\n\n  static parse(tokens: Token[], links: Links, options?: MarkedOptions): string {\n    const parser = new this(options);\n    return parser.parse(links, tokens);\n  }\n\n  parse(links: Links, tokens: Token[]) {\n    this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);\n    this.tokens = tokens.reverse();\n\n    let out = '';\n\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  }\n\n  debug(links: Links, tokens: Token[]) {\n    this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);\n    this.tokens = tokens.reverse();\n\n    let out = '';\n\n    while (this.next()) {\n      const outToken: string = this.tok();\n      this.token.line = this.line += outToken.split('\\n').length - 1;\n      out += outToken;\n    }\n\n    return out;\n  }\n\n  protected next() {\n    return (this.token = this.tokens.pop());\n  }\n\n  protected getNextElement() {\n    return this.tokens[this.tokens.length - 1];\n  }\n\n  protected parseText() {\n    let body = this.token.text;\n    let nextElement: Token;\n\n    while ((nextElement = this.getNextElement()) && nextElement.type == TokenType.text) {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inlineLexer.output(body);\n  }\n\n  protected tok() {\n    switch (this.token.type) {\n      case TokenType.space: {\n        return '';\n      }\n      case TokenType.paragraph: {\n        return this.renderer.paragraph(this.inlineLexer.output(this.token.text));\n      }\n      case TokenType.text: {\n        if (this.options.isNoP) {\n          return this.parseText();\n        } else {\n          return this.renderer.paragraph(this.parseText());\n        }\n      }\n      case TokenType.heading: {\n        return this.renderer.heading(this.inlineLexer.output(this.token.text), this.token.depth, this.token.text);\n      }\n      case TokenType.listStart: {\n        let body = '';\n        const ordered = this.token.ordered;\n\n        while (this.next().type != TokenType.listEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.list(body, ordered);\n      }\n      case TokenType.listItemStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.listItemEnd) {\n          body += this.token.type == (TokenType.text as any) ? this.parseText() : this.tok();\n        }\n\n        return this.renderer.listitem(body);\n      }\n      case TokenType.looseItemStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.listItemEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.listitem(body);\n      }\n      case TokenType.code: {\n        return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);\n      }\n      case TokenType.table: {\n        let header = '';\n        let body = '';\n        let cell;\n\n        // header\n        cell = '';\n        for (let i = 0; i < this.token.header.length; i++) {\n          const flags = { header: true, align: this.token.align[i] };\n          const out = this.inlineLexer.output(this.token.header[i]);\n\n          cell += this.renderer.tablecell(out, flags);\n        }\n\n        header += this.renderer.tablerow(cell);\n\n        for (const row of this.token.cells) {\n          cell = '';\n\n          for (let j = 0; j < row.length; j++) {\n            cell += this.renderer.tablecell(this.inlineLexer.output(row[j]), {\n              header: false,\n              align: this.token.align[j]\n            });\n          }\n\n          body += this.renderer.tablerow(cell);\n        }\n\n        return this.renderer.table(header, body);\n      }\n      case TokenType.blockquoteStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.blockquoteEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.blockquote(body);\n      }\n      case TokenType.hr: {\n        return this.renderer.hr();\n      }\n      case TokenType.html: {\n        const html =\n          !this.token.pre && !this.options.pedantic ? this.inlineLexer.output(this.token.text) : this.token.text;\n        return this.renderer.html(html);\n      }\n      default: {\n        if (this.simpleRenderers.length) {\n          for (let i = 0; i < this.simpleRenderers.length; i++) {\n            if (this.token.type == 'simpleRule' + (i + 1)) {\n              return this.simpleRenderers[i].call(this.renderer, this.token.execArr);\n            }\n          }\n        }\n\n        const errMsg = `Token with \"${this.token.type}\" type was not found.`;\n\n        if (this.options.silent) {\n          console.log(errMsg);\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { BlockLexer } from './block-lexer';\nimport { DebugReturns, LexerReturns, Links, MarkedOptions, SimpleRenderer, Token, TokenType } from './interfaces';\nimport { Parser } from './parser';\n\nexport class Marked {\n  static options = new MarkedOptions();\n  protected static simpleRenderers: SimpleRenderer[] = [];\n\n  /**\n   * Merges the default options with options that will be set.\n   *\n   * @param options Hash of options.\n   */\n  static setOptions(options: MarkedOptions) {\n    Object.assign(this.options, options);\n    return this;\n  }\n\n  /**\n   * Setting simple block rule.\n   */\n  static setBlockRule(regexp: RegExp, renderer: SimpleRenderer = () => '') {\n    BlockLexer.simpleRules.push(regexp);\n    this.simpleRenderers.push(renderer);\n\n    return this;\n  }\n\n  /**\n   * Accepts Markdown text and returns text in HTML format.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options. They replace, but do not merge with the default options.\n   * If you want the merging, you can to do this via `Marked.setOptions()`.\n   */\n  static parse(src: string, options: MarkedOptions = this.options): string {\n    try {\n      const { tokens, links } = this.callBlockLexer(src, options);\n      return this.callParser(tokens, links, options);\n    } catch (e) {\n      return this.callMe(e);\n    }\n  }\n\n  /**\n   * Accepts Markdown text and returns object with text in HTML format,\n   * tokens and links from `BlockLexer.parser()`.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options. They replace, but do not merge with the default options.\n   * If you want the merging, you can to do this via `Marked.setOptions()`.\n   */\n  static debug(src: string, options: MarkedOptions = this.options): DebugReturns {\n    const { tokens, links } = this.callBlockLexer(src, options);\n    let origin = tokens.slice();\n    const parser = new Parser(options);\n    parser.simpleRenderers = this.simpleRenderers;\n    const result = parser.debug(links, tokens);\n\n    /**\n     * Translates a token type into a readable form,\n     * and moves `line` field to a first place in a token object.\n     */\n    origin = origin.map(token => {\n      token.type = (TokenType as any)[token.type] || token.type;\n\n      const line = token.line;\n      delete token.line;\n      if (line) {\n        return { ...{ line }, ...token };\n      } else {\n        return token;\n      }\n    });\n\n    return { tokens: origin, links, result };\n  }\n\n  protected static callBlockLexer(src: string = '', options?: MarkedOptions): LexerReturns {\n    if (typeof src != 'string') {\n      throw new Error(`Expected that the 'src' parameter would have a 'string' type, got '${typeof src}'`);\n    }\n\n    // Preprocessing.\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ')\n      .replace(/\\u00a0/g, ' ')\n      .replace(/\\u2424/g, '\\n')\n      .replace(/^ +$/gm, '');\n\n    return BlockLexer.lex(src, options, true);\n  }\n\n  protected static callParser(tokens: Token[], links: Links, options?: MarkedOptions): string {\n    if (this.simpleRenderers.length) {\n      const parser = new Parser(options);\n      parser.simpleRenderers = this.simpleRenderers;\n      return parser.parse(links, tokens);\n    } else {\n      return Parser.parse(tokens, links, options);\n    }\n  }\n\n  protected static callMe(err: Error) {\n    err.message += '\\nPlease report this to https://github.com/ts-stack/markdown';\n\n    if (this.options.silent) {\n      return '<p>An error occured:</p><pre>' + this.options.escape(err.message + '', true) + '</pre>';\n    }\n\n    throw err;\n  }\n}\n","/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2020, Костя Третяк. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { ExtendRegexp } from './extend-regexp';\nimport {\n  Align,\n  LexerReturns,\n  Links,\n  MarkedOptions,\n  RulesBlockBase,\n  RulesBlockGfm,\n  RulesBlockTables,\n  Token,\n  TokenType,\n} from './interfaces';\nimport { Marked } from './marked';\n\nexport class BlockLexer<T extends typeof BlockLexer> {\n  static simpleRules: RegExp[] = [];\n  protected static rulesBase: RulesBlockBase = null;\n  /**\n   * GFM Block Grammar.\n   */\n  protected static rulesGfm: RulesBlockGfm = null;\n  /**\n   * GFM + Tables Block Grammar.\n   */\n  protected static rulesTables: RulesBlockTables = null;\n  protected rules: RulesBlockBase | RulesBlockGfm | RulesBlockTables;\n  protected options: MarkedOptions;\n  protected links: Links = {};\n  protected tokens: Token[] = [];\n  protected hasRulesGfm: boolean;\n  protected hasRulesTables: boolean;\n\n  constructor(protected staticThis: T, options?: object) {\n    this.options = options || Marked.options;\n    this.setRules();\n  }\n\n  /**\n   * Accepts Markdown text and returns object with tokens and links.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options.\n   */\n  static lex(src: string, options?: MarkedOptions, top?: boolean, isBlockQuote?: boolean): LexerReturns {\n    const lexer = new this(this, options);\n    return lexer.getTokens(src, top, isBlockQuote);\n  }\n\n  protected static getRulesBase(): RulesBlockBase {\n    if (this.rulesBase) {\n      return this.rulesBase;\n    }\n\n    const base: RulesBlockBase = {\n      newline: /^\\n+/,\n      code: /^( {4}[^\\n]+\\n*)+/,\n      hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n      heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n      lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n      blockquote: /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+/,\n      list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n      html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n      def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n      paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n      text: /^[^\\n]+/,\n      bullet: /(?:[*+-]|\\d+\\.)/,\n      item: /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/,\n    };\n\n    base.item = new ExtendRegexp(base.item, 'gm').setGroup(/bull/g, base.bullet).getRegexp();\n\n    base.list = new ExtendRegexp(base.list)\n      .setGroup(/bull/g, base.bullet)\n      .setGroup('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n      .setGroup('def', '\\\\n+(?=' + base.def.source + ')')\n      .getRegexp();\n\n    const tag =\n      '(?!(?:' +\n      'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' +\n      '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' +\n      '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\n    base.html = new ExtendRegexp(base.html)\n      .setGroup('comment', /<!--[\\s\\S]*?-->/)\n      .setGroup('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n      .setGroup('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n      .setGroup(/tag/g, tag)\n      .getRegexp();\n\n    base.paragraph = new ExtendRegexp(base.paragraph)\n      .setGroup('hr', base.hr)\n      .setGroup('heading', base.heading)\n      .setGroup('lheading', base.lheading)\n      .setGroup('blockquote', base.blockquote)\n      .setGroup('tag', '<' + tag)\n      .setGroup('def', base.def)\n      .getRegexp();\n\n    return (this.rulesBase = base);\n  }\n\n  protected static getRulesGfm(): RulesBlockGfm {\n    if (this.rulesGfm) {\n      return this.rulesGfm;\n    }\n\n    const base = this.getRulesBase();\n\n    const gfm: RulesBlockGfm = {\n      ...base,\n      ...{\n        fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n        paragraph: /^/,\n        heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/,\n      },\n    };\n\n    const group1 = gfm.fences.source.replace('\\\\1', '\\\\2');\n    const group2 = base.list.source.replace('\\\\1', '\\\\3');\n\n    gfm.paragraph = new ExtendRegexp(base.paragraph).setGroup('(?!', `(?!${group1}|${group2}|`).getRegexp();\n\n    return (this.rulesGfm = gfm);\n  }\n\n  protected static getRulesTable(): RulesBlockTables {\n    if (this.rulesTables) {\n      return this.rulesTables;\n    }\n\n    return (this.rulesTables = {\n      ...this.getRulesGfm(),\n      ...{\n        nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n        table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n      },\n    });\n  }\n\n  protected setRules() {\n    if (this.options.gfm) {\n      if (this.options.tables) {\n        this.rules = this.staticThis.getRulesTable();\n      } else {\n        this.rules = this.staticThis.getRulesGfm();\n      }\n    } else {\n      this.rules = this.staticThis.getRulesBase();\n    }\n\n    this.hasRulesGfm = (this.rules as RulesBlockGfm).fences !== undefined;\n    this.hasRulesTables = (this.rules as RulesBlockTables).table !== undefined;\n  }\n\n  /**\n   * Lexing.\n   */\n  protected getTokens(src: string, top?: boolean, isBlockQuote?: boolean): LexerReturns {\n    let nextPart = src;\n    let execArr: RegExpExecArray;\n\n    mainLoop: while (nextPart) {\n      // newline\n      if ((execArr = this.rules.newline.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[0].length > 1) {\n          this.tokens.push({ type: TokenType.space });\n        }\n      }\n\n      // code\n      if ((execArr = this.rules.code.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const code = execArr[0].replace(/^ {4}/gm, '');\n\n        this.tokens.push({\n          type: TokenType.code,\n          text: !this.options.pedantic ? code.replace(/\\n+$/, '') : code,\n        });\n        continue;\n      }\n\n      // fences code (gfm)\n      if (this.hasRulesGfm && (execArr = (this.rules as RulesBlockGfm).fences.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.tokens.push({\n          type: TokenType.code,\n          lang: execArr[2],\n          text: execArr[3] || '',\n        });\n        continue;\n      }\n\n      // heading\n      if ((execArr = this.rules.heading.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({\n          type: TokenType.heading,\n          depth: execArr[1].length,\n          text: execArr[2],\n        });\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (top && this.hasRulesTables && (execArr = (this.rules as RulesBlockTables).nptable.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        const item: Token = {\n          type: TokenType.table,\n          header: execArr[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n          align: execArr[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */) as Align[],\n          cells: [],\n        };\n\n        for (let i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        const td: string[] = execArr[3].replace(/\\n$/, '').split('\\n');\n\n        for (let i = 0; i < td.length; i++) {\n          item.cells[i] = td[i].split(/ *\\| */);\n        }\n\n        this.tokens.push(item);\n        continue;\n      }\n\n      // lheading\n      if ((execArr = this.rules.lheading.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.tokens.push({\n          type: TokenType.heading,\n          depth: execArr[2] === '=' ? 1 : 2,\n          text: execArr[1],\n        });\n        continue;\n      }\n\n      // hr\n      if ((execArr = this.rules.hr.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.hr });\n        continue;\n      }\n\n      // blockquote\n      if ((execArr = this.rules.blockquote.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.blockquoteStart });\n        const str = execArr[0].replace(/^ *> ?/gm, '');\n\n        // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        this.getTokens(str);\n        this.tokens.push({ type: TokenType.blockquoteEnd });\n        continue;\n      }\n\n      // list\n      if ((execArr = this.rules.list.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const bull: string = execArr[2];\n\n        this.tokens.push({ type: TokenType.listStart, ordered: bull.length > 1 });\n\n        // Get each top-level item.\n        const str = execArr[0].match(this.rules.item);\n        const length = str.length;\n\n        let next = false;\n        let space: number;\n        let blockBullet: string;\n        let loose: boolean;\n\n        for (let i = 0; i < length; i++) {\n          let item = str[i];\n\n          // Remove the list item's bullet so it is seen as the next token.\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n          // Outdent whatever the list item contains. Hacky.\n          if (item.indexOf('\\n ') !== -1) {\n            space -= item.length;\n            item = !this.options.pedantic\n              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n              : item.replace(/^ {1,4}/gm, '');\n          }\n\n          // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n          if (this.options.smartLists && i !== length - 1) {\n            blockBullet = this.staticThis.getRulesBase().bullet.exec(str[i + 1])[0];\n\n            if (bull !== blockBullet && !(bull.length > 1 && blockBullet.length > 1)) {\n              nextPart = str.slice(i + 1).join('\\n') + nextPart;\n              i = length - 1;\n            }\n          }\n\n          // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== length - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n\n            if (!loose) {\n              loose = next;\n            }\n          }\n\n          this.tokens.push({ type: loose ? TokenType.looseItemStart : TokenType.listItemStart });\n\n          // Recurse.\n          this.getTokens(item, false, isBlockQuote);\n          this.tokens.push({ type: TokenType.listItemEnd });\n        }\n\n        this.tokens.push({ type: TokenType.listEnd });\n        continue;\n      }\n\n      // html\n      if ((execArr = this.rules.html.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const attr = execArr[1];\n        const isPre = attr === 'pre' || attr === 'script' || attr === 'style';\n\n        this.tokens.push({\n          type: this.options.sanitize ? TokenType.paragraph : TokenType.html,\n          pre: !this.options.sanitizer && isPre,\n          text: execArr[0],\n        });\n        continue;\n      }\n\n      // def\n      if (top && (execArr = this.rules.def.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.links[execArr[1].toLowerCase()] = {\n          href: execArr[2],\n          title: execArr[3],\n        };\n        continue;\n      }\n\n      // table (gfm)\n      if (top && this.hasRulesTables && (execArr = (this.rules as RulesBlockTables).table.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        const item: Token = {\n          type: TokenType.table,\n          header: execArr[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n          align: execArr[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */) as Align[],\n          cells: [],\n        };\n\n        for (let i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        const td = execArr[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n');\n\n        for (let i = 0; i < td.length; i++) {\n          item.cells[i] = td[i].replace(/^ *\\| *| *\\| *$/g, '').split(/ *\\| */);\n        }\n\n        this.tokens.push(item);\n        continue;\n      }\n\n      // simple rules\n      if (this.staticThis.simpleRules.length) {\n        const simpleRules = this.staticThis.simpleRules;\n        for (let i = 0; i < simpleRules.length; i++) {\n          if ((execArr = simpleRules[i].exec(nextPart))) {\n            nextPart = nextPart.substring(execArr[0].length);\n            const type = 'simpleRule' + (i + 1);\n            this.tokens.push({ type, execArr });\n            continue mainLoop;\n          }\n        }\n      }\n\n      // top-level paragraph\n      if (top && (execArr = this.rules.paragraph.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[1].slice(-1) === '\\n') {\n          this.tokens.push({\n            type: TokenType.paragraph,\n            text: execArr[1].slice(0, -1),\n          });\n        } else {\n          this.tokens.push({\n            type: this.tokens.length > 0 ? TokenType.paragraph : TokenType.text,\n            text: execArr[1],\n          });\n        }\n        continue;\n      }\n\n      // text\n      // Top-level should never reach here.\n      if ((execArr = this.rules.text.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.text, text: execArr[0] });\n        continue;\n      }\n\n      if (nextPart) {\n        throw new Error(\n          'Infinite loop on byte: ' + nextPart.charCodeAt(0) + `, near text '${nextPart.slice(0, 30)}...'`\n        );\n      }\n    }\n\n    return { tokens: this.tokens, links: this.links };\n  }\n}\n"]}