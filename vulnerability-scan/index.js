const core = require("@actions/core");
const fetch = require("node-fetch");
const github = require("@actions/github");

async function run() {
    const jiraUsername = core.getInput("jira_username", { required: true });
    const jiraToken = core.getInput("jira_token", { required: true });
    const quayToken = core.getInput("quay_token", { required: true });
    const tag = core.getInput("tag", { required: true });
    const imageReposInput = core.getInput("image_repos", { required: true });
    const quayContainers = imageReposInput.split(',').map(container => container.trim());

    const authToken =
        "Basic " +
        Buffer.from(jiraUsername + ":" + jiraToken).toString("base64");

    let vulnerabilities = {};
    for (const quayContainer of quayContainers) {
        const features= await getFeatures(quayToken, quayContainer, tag);
        if(features === null) {
            // this means that the vulnerability scan is not available on the container, continue with other containers
            continue;
        }
        vulnerabilities = await accumulateVulnerabilities(features, vulnerabilities, quayContainer);
    }
    
    for (const CVEId in vulnerabilities) {
        const vulnerability = vulnerabilities[CVEId];

        // Iterate over each container in the vulnerability
        for (const container of vulnerability.containers) {
            const searchResult = await searchJiraIssue(authToken, CVEId);
            const issues = searchResult.issues;

            if(issues.length === 0) {
                await createJiraIssue(authToken, { ...vulnerability, containers: [container] });
                continue;
            }
            
            let containerHandled = false; // Flag to track if container name is handled

            for (const jiraIssue of issues) {
                const jiraIssueStatus = jiraIssue.fields.status.name.toLocaleLowerCase();
                const currentDescription = jiraIssue.fields.description;

                // Check if container name is already present in the description for any status
                if (JSON.stringify(currentDescription).includes(container)) {
                    containerHandled = true;
                    // If the issue status is "done" or "not done", we should open a new issue anyway
                    if (["done"].includes(jiraIssueStatus)) {
                        containerHandled = false;
                    }
                    break; // Exit the loop as we've found the container name in an existing issue
                }
            }

            // If container name is not handled by any existing issue
            if (!containerHandled) {
                const specificVulnerability = { ...vulnerability, containers: [container] };
                // Check for issues with statuses "in progress", "in review", "code merged"
                const inProgressIssues = issues.filter(issue => ["in progress", "in review", "code merged"].includes(issue.fields.status.name.toLocaleLowerCase()));

                if (inProgressIssues.length > 0) {
                    await createJiraIssue(authToken, specificVulnerability);
                } else {
                    // Check for "to do" issues
                    const todoIssues = issues.filter(issue => !["in progress", "in review", "code merged", "done", "not done"].includes(issue.fields.status.name.toLocaleLowerCase()));

                    if (todoIssues.length > 0) {
                        await addContainerNameToJiraIssue(authToken, todoIssues[0].id, todoIssues[0].fields.description, [container]);
                    } else {
                        await createJiraIssue(authToken, specificVulnerability);
                    }
                }
            }
        }
    }
}

const priority = {
    critical: { id: "1", dueDays: 2 },
    high: { id: "2", dueDays: 30 },
    medium: { id: "3", dueDays: 90 },
};

async function getManifestDigest(quayToken, container, tagName) {
    const response = await fetch(
        `https://quay.io/api/v1/repository/${container}/tag?onlyActiveTags=true&filter_tag_name=eq:${tagName}`,
        {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${quayToken}`,
            },
        }
    );
    if (!response.ok) {
        throw new Error(
            `Error fetching container tag details container: ${container} | response status text: ${response.statusText}`
        );
    }
    const responseBody = await response.json();
    return responseBody.tags[0].manifest_digest;
}

async function getFeatures(quayToken, container, quayTag) {
    const manifestDigest = await getManifestDigest(quayToken, container, quayTag);
    
    const response = await fetch(
        `https://quay.io/api/v1/repository/${container}/manifest/${manifestDigest}/security?vulnerabilities=true`,
        {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${quayToken}`,
            },
        }
    );
    if (!response.ok) {
        throw new Error(
            `Error fetching vulnerabilities for container ${container}: ${response.statusText}`
        );
    }
    const responseBody = await response.json();
    return responseBody.data !== null ? responseBody.data.Layer.Features : null;
}

async function accumulateVulnerabilities(features, vulnerabilities, quayContainer) {
    for (const feature of features) {
        for (const vulnerability of feature.Vulnerabilities) {
            const severity = vulnerability.Severity.toLocaleLowerCase();
            if (
                severity === "critical" ||
                (["medium", "high"].includes(severity) &&
                    vulnerability.FixedBy !== "")
            ) {
                const cveRegex = /CVE-\d{4}-\d+/;
                const vulnerabilityName = vulnerability.Name.match(cveRegex)?.[0]
                || vulnerability.Link.match(cveRegex)?.[0]
                || vulnerability.Name;
                const {description, dueDate} = await getVulnerabilityDetails(vulnerabilityName, severity);
                if (!vulnerabilities[vulnerabilityName]) {
                    vulnerabilities[vulnerabilityName] = {
                        vulnerabilityName,
                        description: description,
                        link: vulnerability.Link.split(" ")[0],
                        severity,
                        containers: [],
                        dueDate: dueDate
                    };
                }
                if (!vulnerabilities[vulnerabilityName].containers.includes(quayContainer)) {
                    vulnerabilities[vulnerabilityName].containers.push(quayContainer);
                }
            }
        }
    }

    return vulnerabilities;
}

async function getCVEData(CVEId) {
    const response = await fetch(`https://cveawg.mitre.org/api/cve/${CVEId}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
        },
    });
    if (!response.ok) {
        throw new Error(
            `Error fetching CVE data for ${CVEId}: ${response.statusText}`
        );
    }
    return response.json();
}

async function getGHSAData(id) {
    const githubToken = core.getInput("github_token", { required: true });
    const client = new github.getOctokit(githubToken);
    try {
        const response = await client.request('GET /advisories/{ghsa_id}', {
            ghsa_id: id
        });
        return response.data;
    } catch (error) {
        console.error(`Error fetching GHSA details: GHSAId: ${id}, error: ${error}`);
    }
}

async function getVulnerabilityDetails(vulnerabilityId, priorityLevel) {
    let description = "";
    let publishedDate;
    
    switch (true) {
        case vulnerabilityId.startsWith("CVE"):
            const cveData = await getCVEData(vulnerabilityId);
            description = cveData.containers.cna.descriptions[0].value;
            publishedDate = new Date(cveData.cveMetadata.datePublished);
            break;
        case vulnerabilityId.startsWith("GHSA"):
            const ghsa = await getGHSAData(vulnerabilityId);
            description = ghsa.description;
            publishedDate = new Date(ghsa.published_at);
            break;
        default:
            throw new Error(
                `unhandled vulnerabilityId for get description ${vulnerabilityId}`
            );
    }
    const dueDays = priority[priorityLevel].dueDays;
    const dueDate = (new Date(
        publishedDate.getTime() + dueDays * 24 * 60 * 60 * 1000
    )).toISOString().split("T")[0];
    return {description, dueDate};
}

async function searchJiraIssue(authToken, CVEId) {
    const response = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/search?jql=project=TN AND summary~${CVEId} AND issuetype="Task"`,
        {
            method: "GET",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
        }
    );
    if (!response.ok) {
        throw new Error(`Error searching Jira issue: ${response.statusText}`);
    }
    return response.json();
}

async function addContainerNameToJiraIssue(authToken, issueId, currentDescription, newContainerNames) {
    const updatedDescription = {
        ...currentDescription,
        content: [
            ...currentDescription.content,
            {
                type: "bulletList",
                content: newContainerNames.map(container => ({
                    type: "listItem",
                    content: [
                        {
                            type: "paragraph",
                            content: [
                                {
                                    type: "text",
                                    text: "Container: ",
                                },
                                {
                                    type: "text",
                                    text: container,
                                    marks: [
                                        {
                                            type: "strong",
                                        },
                                    ],
                                },
                            ],
                        },
                    ],
                })),
            },
        ],
    };

    const response = await fetch(`https://tonic-ai.atlassian.net/rest/api/3/issue/${issueId}`, {
        method: 'PUT',
        headers: {
            Authorization: authToken,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            fields: {
                description: updatedDescription,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(
            `Error adding containers to Jira issue description: ${response.statusText}`
        );
    }
}

async function createJiraIssue(
    authToken,
    vulnerability
) {
    const issue = {
        fields: {
            project: { id: "10001" },
            summary: vulnerability.vulnerabilityName,
            issuetype: { id: "10005" },
            description: {
                version: 1,
                type: "doc",
                content: [
                    {
                        type: "paragraph",
                        content: [
                            {
                                type: "text",
                                text: `${vulnerability.description}\n`,
                            },
                        ],
                    },
                    {
                        type: "paragraph",
                        content: [
                            {
                                type: "text",
                                text: "Vulnerability Link:",
                                marks: [
                                    {
                                        type: "strong",
                                    },
                                ],
                            },
                            {
                                type: "inlineCard",
                                attrs: {
                                    url: ` ${vulnerability.link}\n`,
                                },
                            },
                        ],
                    },
                    {
                        type: "bulletList",
                        content: vulnerability.containers.map(container => ({
                            type: "listItem",
                            content: [
                                {
                                    type: "paragraph",
                                    content: [
                                        {
                                            type: "text",
                                            text: "Container: ",
                                        },
                                        {
                                            type: "text",
                                            text: `${container}`,
                                            marks: [
                                                {
                                                    type: "strong",
                                                },
                                            ],
                                        },
                                    ],
                                },
                            ],
                        })),
                    },
                ],
            },
            labels: ["security", "security-vulnerability"],
            customfield_10035: {
                value: "Platform & Tooling",
                id: "10034",
            },
            priority: { id: priority[vulnerability.severity].id },
            duedate: vulnerability.dueDate,
        },
    };

    const createTicketResponse = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/issue`,
        {
            method: "POST",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(issue),
        }
    );
    if (!createTicketResponse.ok) {
        throw new Error(
            `Error creating Jira issue: ${createTicketResponse.statusText}`
        );
    }
    const createTicketResponseBody = await createTicketResponse.json();
    
    console.log(`Created a new JIRA issue with key: ${createTicketResponseBody.key}`);

    // update jira ticket to Ready for Development status
    const updateStatusResponse = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/issue/${createTicketResponseBody.key}/transitions`,
        {
            method: "POST",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ transition: { id: "41" } }),
        }
    );
    if (!updateStatusResponse.ok) {
        throw new Error(
            `Error updating Jira issue status: ${updateStatusResponse.statusText}`
        );
    }

    return createTicketResponseBody;
}

run().catch((error) => {
    core.setFailed(error.message);
    if (error instanceof Error && error.stack) {
        core.debug(error.stack);
    }
});
