const core = require("@actions/core");
const fetch = require("node-fetch");
async function run() {
    console.log("inside of action");
    const jiraUsername = core.getInput("jira_username", { required: true });
    const jiraToken = core.getInput("jira_token", { required: true });
    const quayToken = core.getInput("quay_token", { required: true });
    const quayTag = core.getInput("quay_tag", { required: true });
    const quayContainersInput = core.getInput("quay_containers", { required: true });
    const quayContainers = quayContainersInput.split(',').map(container => container.trim());
    console.log(`quayContainers: ${quayContainers}`);

    const authToken =
        "Basic " +
        Buffer.from(jiraUsername + ":" + jiraToken).toString("base64");

    for (const quayContainer of quayContainers) {
        const manifestDigest = await getManifestDigest(
            quayToken,
            quayContainer,
            quayTag
        );
        const getVulnerabilitiesBody = await getVulnerabilities(
            quayToken,
            quayContainer,
            manifestDigest
        );

        const features = getVulnerabilitiesBody.data.Layer.Features;
        const vulnerableFeatures = filterVulnerableFeatures(features);

        for (const feature of vulnerableFeatures) {
            for (const CVEId of feature.CVEIds) {
                const vulnerability = feature.Vulnerabilities.find((v) =>
                    v.Name.includes(CVEId)
                );
                const severity = vulnerability.Severity.toLocaleLowerCase();
                if (
                    severity === "critical" ||
                    (["medium", "high"].includes(severity) &&
                        vulnerability.FixedBy !== "")
                ) {
                    const searchResult = await searchJiraIssue(
                        authToken,
                        CVEId
                    );
                    if (searchResult.issues.length > 0) {
                        // If a ticket already exists, update it with the new container info if not already present
                        const jiraIssue = searchResult.issues[0];
                        const currentDescription = jiraIssue.fields.description;
                        if (
                            !JSON.stringify(currentDescription).includes(
                                quayContainer
                            )
                        ) {
                            await addContainerNameToJiraIssue(
                                authToken,
                                jiraIssue.id,
                                currentDescription,
                                quayContainer
                            );
                        }
                    } else {
                        // If no ticket exists, create a new one
                        const resp = await createJiraIssue(
                            authToken,
                            quayContainer,
                            vulnerability,
                            CVEId,
                            severity
                        );
                        console.log(
                            `Created jira ticket with Jira Key: ${resp.key}`
                        );
                    }
                }
            }
        }
    }
}

const priority = {
    critical: { id: "1", dueDays: 2 },
    high: { id: "2", dueDays: 30 },
    medium: { id: "3", dueDays: 90 },
};

async function getManifestDigest(quayToken, container, tagName) {
    const response = await fetch(
        `https://quay.io/api/v1/repository/${container}/tag?onlyActiveTags=true&filter_tag_name=eq:${tagName}`,
        {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${quayToken}`,
            },
        }
    );
    if (!response.ok) {
        throw new Error(
            `Error fetching container tag details container: ${container} | response status text: ${response.statusText}`
        );
    }
    const responseBody = await response.json();
    return responseBody.tags[0].manifest_digest;
}

async function getVulnerabilities(quayToken, container, manifestDigest) {
    const response = await fetch(
        `https://quay.io/api/v1/repository/${container}/manifest/${manifestDigest}/security?vulnerabilities=true`,
        {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${quayToken}`,
            },
        }
    );
    if (!response.ok) {
        throw new Error(
            `Error fetching vulnerabilities for container ${container}: ${response.statusText}`
        );
    }
    return response.json();
}

function filterVulnerableFeatures(features) {
    return features.filter((feature) =>
        feature.Vulnerabilities.some((vulnerability) => {
            const severity = vulnerability.Severity.toLocaleLowerCase();
            return (
                severity === "critical" ||
                (["medium", "high"].includes(severity) &&
                    !vulnerability.FixedBy)
            );
        })
    );
}

async function getCVEData(CVEId) {
    const response = await fetch(`https://cveawg.mitre.org/api/cve/${CVEId}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
        },
    });
    if (!response.ok) {
        throw new Error(
            `Error fetching CVE data for ${CVEId}: ${response.statusText}`
        );
    }
    return response.json();
}
async function calculateDueDate(CVEId, priorityLevel) {
    const cveData = await getCVEData(CVEId);
    const publishedDate = new Date(cveData.cveMetadata.datePublished);
    const dueDays = priority[priorityLevel].dueDays;
    const dueDate = new Date(
        publishedDate.getTime() + dueDays * 24 * 60 * 60 * 1000
    );
    return dueDate.toISOString().split("T")[0];
}

async function searchJiraIssue(authToken, CVEId) {
    const response = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/search?jql=project=TN AND summary~${CVEId} AND issuetype="Task"`,
        {
            method: "GET",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
        }
    );
    if (!response.ok) {
        throw new Error(`Error searching Jira issue: ${response.statusText}`);
    }
    return response.json();
}

async function addContainerNameToJiraIssue(
    authToken,
    jiraIssueId,
    currentDescription,
    containerName
) {
    const descriptionContent = currentDescription.content;
    let bulletList = descriptionContent.find(
        (item) => item.type === "bulletList"
    );
    if (!bulletList) {
        bulletList = {
            type: "bulletList",
            content: [],
        };
    }

    const listItem = {
        type: "listItem",
        content: [
            {
                type: "paragraph",
                content: [
                    {
                        type: "text",
                        text: "Container: ",
                    },
                    {
                        type: "text",
                        text: `${containerName}`,
                        marks: [
                            {
                                type: "strong",
                            },
                        ],
                    },
                ],
            },
        ],
    };
    bulletList.content.push(listItem);
    const updateBody = {
        update: {
            description: [
                {
                    set: {
                        type: "doc",
                        version: 1,
                        content: descriptionContent,
                    },
                },
            ],
        },
    };
    const updateResponse = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/issue/${jiraIssueId}`,
        {
            method: "PUT",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(updateBody),
        }
    );

    if (!updateResponse.ok) {
        throw new Error(
            `Error updating Jira issue: ${updateResponse.statusText}`
        );
    }
}

async function createJiraIssue(
    authToken,
    containerName,
    vulnerability,
    CVEId,
    severity
) {
    const dueDate = await calculateDueDate(CVEId, severity);
    const issue = {
        fields: {
            project: { id: "10001" },
            summary: CVEId,
            issuetype: { id: "10005" },
            description: {
                version: 1,
                type: "doc",
                content: [
                    {
                        type: "paragraph",
                        content: [
                            {
                                type: "text",
                                text: `${vulnerability.Description}\n`,
                            },
                        ],
                    },
                    {
                        type: "paragraph",
                        content: [
                            {
                                type: "text",
                                text: "Vulnerability Link:",
                                marks: [
                                    {
                                        type: "strong",
                                    },
                                ],
                            },
                            {
                                type: "inlineCard",
                                attrs: {
                                    url: ` ${vulnerability.Link}\n`,
                                },
                            },
                        ],
                    },
                    {
                        type: "bulletList",
                        content: [
                            {
                                type: "listItem",
                                content: [
                                    {
                                        type: "paragraph",
                                        content: [
                                            {
                                                type: "text",
                                                text: "Container: ",
                                            },
                                            {
                                                type: "text",
                                                text: `${containerName}`,
                                                marks: [
                                                    {
                                                        type: "strong",
                                                    },
                                                ],
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                ],
            },
            labels: ["security", "security-vulnerability"],
            customfield_10035: {
                value: "Platform & Tooling",
                id: "10034",
            },
            priority: { id: priority[severity].id },
            duedate: dueDate,
        },
    };

    const createTicketResponse = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/issue`,
        {
            method: "POST",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(issue),
        }
    );
    if (!createTicketResponse.ok) {
        throw new Error(
            `Error creating Jira issue: ${createTicketResponse.statusText}`
        );
    }
    const createTicketResponseBody = await createTicketResponse.json();

    // update jira ticket to Ready for Development status
    const updateStatusResponse = await fetch(
        `https://tonic-ai.atlassian.net/rest/api/3/issue/${createTicketResponseBody.key}/transitions`,
        {
            method: "POST",
            headers: {
                Authorization: authToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ transition: { id: "41" } }),
        }
    );
    if (!updateStatusResponse.ok) {
        throw new Error(
            `Error updating Jira issue status: ${updateStatusResponse.statusText}`
        );
    }

    return createTicketResponseBody;
}

run().catch((error) => {
    core.setFailed(error.message);
    if (error instanceof Error && error.stack) {
        core.debug(error.stack);
    }
});
